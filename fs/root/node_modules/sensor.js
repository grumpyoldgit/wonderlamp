
//
// Node moudle that represents a sensor
//

var smoother = require('smoother.js');
var osc = require('osc.js');

/*

Sensors are created with the necessary Fader and OSC Client information, and are responsible
for sending properly-smoothed values to the OSC host, as appropriate when updated.

*/

function Sensor(ip, smootherSize, oscHost, oscPort, midiChannel, debug, min, max, timeout) {
	this.ip = ip
	this.smoother = smoother.createSmoother(smootherSize);
	this.fader = osc.createFader(oscHost, oscPort, midiChannel);
	this.last = 0;
	this.debug = debug;
	if (min >= max) {
		throw new RangeError("max has to be bigger than min for a sensor to function");
	}
	this.min = min;
	this.max = max;
	this.deadzone = max; // will push the maximum value when in the deadzone
	this.timeout = timeout;
	console.log(
		"Sensor IP: " + ip + " to osc host " + oscHost + " on port "
		+ oscPort + " Min:" + min + " Max:" + max + " with debug " + debug + "."
	);
	this.fader.send(0); // reset each channel as it is setup
}


Sensor.prototype.bite = function (s) {
	// keep pushing zero values every 20 ms until there's a zero
	if (s.smoother.average() != s.deadzone) {
		s.pushInput(s.deadzone);
		setTimeout(s.bite, 100, s);
	} else {
		// bite is complete, no need to watchdog any longer for this sensor
		// unless a new input comes in (see comments below)
	}
}

Sensor.prototype.watchdog = function (timeoutInSeconds) {
	clearTimeout(this.timer);
	this.timer = setTimeout(function(s) {
		s.bite(s);
	}, timeoutInSeconds * 1000, this);
}

Sensor.prototype.pushInput = function (distanceInInches) {
	// We call the watchdog every time an input is pushed.
	this.watchdog(2);

	// That clears the existing watchdog, and that has two cases:
	//   - The watchdog hasn't yet been triggered 
	//        => Now the timer has been extended
	//   - The watchdog is currently biting (bite calls pushInput) 
	//        => The bite will continue using the anonymous timer, and the main
	//           watchdog (this.timer) will get reset when the bite is complete

	if (distanceInInches > 255 || distanceInInches < 0) { 	// sanity check for noise
		return;
	}

	if (distanceInInches > this.max || distanceInInches < this.min) {
		this.smoother.pushInput(this.deadzone); // in the deadzone, nobody cares what your distance sensor reads
	} else {
		this.smoother.pushInput(distanceInInches); // the smoother collects real inch values
	}

	var smoothed = this.smoother.average();
	var oscValue = 1.0 - ((smoothed - this.min) / (this.max - this.min));

	if (smoothed != this.last) {
		this.last = smoothed;

		if (this.debug) {
			console.log("DEBUG - IP: " + this.ip + " Raw distance: " +  distanceInInches + " scaled value: " + this.last.toFixed(2) + "OSC: " + oscValue.toFixed(5));
		}
		this.fader.send(oscValue);
	}
}

Sensor.prototype.toString = function () {
	return "[Sensor object]";
}

module.exports = {
	createSensor: function(ip, smootherSize, oscHost, oscPort, midiChannel, debug, min, max, timeout) {
		return new Sensor(ip, smootherSize, oscHost, oscPort, midiChannel, debug, min, max, timeout);
	}
}