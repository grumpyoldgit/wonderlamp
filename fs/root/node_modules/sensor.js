
//
// Node moudle that represents a sensor
//

var smoother = require('smoother.js');
var osc = require('osc.js');

/*

Sensors are created with the necessary Fader and OSC Client information, and are responsible
for sending properly-smoothed values to the OSC host, as appropriate when updated.

*/

function Sensor(ip, smootherSize, oscHost, oscPort, midiChannel, debug, min, max, timeout) {
	this.ip = ip
	this.smoother = smoother.createSmoother(smootherSize);
	this.fader = osc.createFader(oscHost, oscPort, midiChannel);
	this.last = 0;
	this.debug = debug;
	if (min >= max) {
		throw new RangeError("max has to be bigger than min for a sensor to function");
	}
	this.min = min;
	this.max = max;
	this.timeout = timeout;
	console.log(
		"Sensor IP: " + ip + " to osc host " + oscHost + " on port "
		+ oscPort + " Min:" + min + " Max:" + max + " with debug " + debug + "."
	);
	this.fader.send(0); // reset each channel as it is setup
}


Sensor.prototype.bite = function (s) {
	// keep pushing zero values every 20 ms until there's a zero
	console.log("biting");
	if (s.smoother.average() > 0) {
		s.smoother.pushInput(0);
		setTimeout(s.bite, 20, s);
	} else {
		// bite is complete, no need to watchdog any longer for this sensor
		// unless a new input comes in (see comments below)
	}
}

Sensor.prototype.watchdog = function (timeoutInSeconds) {
	clearTimeout(this.timer);
	this.timer = setTimeout(function(s) {
		s.bite(s);
	}, timeoutInSeconds, this);
}

Sensor.prototype.pushInput = function (distanceInInches) {
	// We call the watchdog every time an input is pushed.
	//this.watchdog(60);

	// That clears the existing watchdog, and that has two cases:
	//   - The watchdog hasn't yet been triggered 
	//        => Now the timer has been extended
	//   - The watchdog is currently biting (bite calls pushInput) 
	//        => The bite will continue using the anonymous timer, and the main
	//           watchdog (this.timer) will get reset when the bite is complete

	if (distanceInInches > 255 || distanceInInches < 0) { 	// sanity check for noise
		return;
	}

	// lj-clipping 1: Added 'dead' zones where the value counts as zero
	if (distanceInInches > this.max || distanceInInches < this.min) {
		this.smoother.pushInput(1); // push 1 for a dead zone
	} else {
		// Each value will now get scaled between 0 to 255 between min and max:
		//  see http://stackoverflow.com/questions/929103/convert-a-number-range-to-another-range-maintaining-ratio
		var OldRange = 255;
		var NewRange = (this.max - this.min);
		var NewValue = (((distanceInInches - 0) * NewRange) / OldRange) + this.min
		this.smoother.pushInput(NewValue); // push new valid input
	}

	var smoothed = this.smoother.average();

	if (smoothed != this.last) {
		this.last = smoothed;
		var oscValue = 1 - (this.last / 100); // the closer you are, the higher the OSC value. 1 = 100%, 0 = 0%
		if (this.debug) {
			console.log("DEBUG - IP: " + this.ip + " Raw distance: " +  distanceInInches + " scaled value: " + this.last + "OSC: " + oscValue);
		}
		this.fader.send(oscValue);
	}
}

Sensor.prototype.toString = function () {
	return "[Sensor object]";
}

module.exports = {
	createSensor: function(ip, smootherSize, oscHost, oscPort, midiChannel, debug, min, max, timeout) {
		return new Sensor(ip, smootherSize, oscHost, oscPort, midiChannel, debug, min, max, timeout);
	}
}